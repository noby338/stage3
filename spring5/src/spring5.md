# springMVC6

* Spring实现AOP的过程
  * Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。
* Spring AOP的底层实现原理
  * 基于动态代理技术，spring框架会根据目标类是否实现了接口来决定采用jdk或cglib动态代理的方式。
* Spring实现动态代理的两种方式(代理对象由目标对象和增强代码组成)
  * JDK 代理：基于目标对象的父接口生成代理对象
  * cglib 代理：基于目标对象(父类)生成的代理对象(子类)
* AOP 编程术语
  * Target（目标对象）：代理的目标对象(将被增强的对象)
  * Proxy （代理对象）：一个类被 AOP 织入增强后，就产生一个结果代理类(被增强后的对象)
  * Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点(可以插入增强代码的方法)
  * Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义(已经插入增强代码的方法)
  * Advice（通知/增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知(增强代码)
  * Aspect（切面）：是切入点和通知（引介）的结合(增强代码和被增强的方法)
  * Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入(将增强代码插入增强方法的过程)
* 配置文件配置AOP的方式
  * 编写核心业务代码（将被增强的对象的方法）
  * 编写切面类，切面类中有通知(增强代码)
  * 在配置文件中，配置织入关系，即将哪些通知与哪些连接点进行结合
    * 切点表达式
      * 切点表达式的写法execution([修饰符] 返回值类型 包名.类名.方法名(参数))：
        * 访问修饰符可以省略
        * 返回值类型、包名、类名、方法名可以使用星号* 代表任意
        * 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类
        * 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表
      * 例如
        * execution(public void com.itheima.aop.Target.method()) 指定包的指定方法增强
        * execution(void com.itheima.aop.Target.*(..)) 指定包Target类，返回值为void，参数为任意的方法增强
        * execution(* com.itheima.aop.*.*(..)) 指定包的任意类，返回值为任意，参数为任意的方法增强
        * execution(* com.itheima.aop..*.*(..)) 指定包及其子包的任意类，返回值为任意，参数为任意的方法增强
      * 切点表达式的抽取
    * 通知的种类
      * 前置通知 <aop:before> 用于配置前置通知。指定增强的方法在切入点方法之前执行
      * 后置通知 <aop:after-returning> 用于配置后置通知。指定增强的方法在切入点方法之后执行
      * 环绕通知 <aop:around> 用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行
      * 异常抛出通知 <aop:throwing> 用于配置异常抛出通知。指定增强的方法在出现异常时执行
      * 最终通知 <aop:after> 用于配置最终通知。无论增强方式执行是否有异常都会执行
* 注解配置AOP的方式
  * @Aspect 标注切面类
  * @Before 前置通知
  * @AfterReturning 后置通知
  * @Around 环绕通知
  * @AfterThrowing 异常抛出通知
  * After 最终通知
  * @Pointcut 切面表达式注解
